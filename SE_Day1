[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18475526&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment
Part 1: Introduction to Software Engineering
1. Explain what software engineering is and discuss its importance in the technology industry.
Software Engineering is a branch of computer science essential for developing, testing, deploying and maintaining of programs and softwares.
(i). Innovation:- Software engineering provides the tools and frameworks that enable developers to create innovative solutions.
(ii). Scalability: Well-engineered software can be easily updated, debugged, and scaled according to users' needs, tastes, and preferences.
(iii) Flexibility: Well-designed software ensures that the system can handle an increased load without affecting performance.
(iv). Efficiency:- Software engineering helps to optimize developer workflow while maintaining high quality standards.
(v). Security:- Software engineering implements practices for building secure systems, protecting sensitive data, minimising vulnerabilities and ensuring compliance with ethical regulations.


2. Identify and describe at least three key milestones in the evolution of software engineering.
(i). The Advent of High-Level Programming Languages (1950s-1960s):-The development of high-level programming languages like FORTRAN (1957) and COBOL (1959) marked a significant shift from machine-level and assembly languages. These languages allowed developers to write code that was more human-readable and easier to maintain.
(ii). The Introduction of Structured Programming (1970s):-The development of structured programming improved software reliability and maintainability. It encouraged the use of clear, hierarchical structures instead of complex, unstructured code. Languages like Pascal and C were developed and supported structured programming.
(iii). The Emergence of Agile SDLC and DevOps (2000s): Agile Methodology was created by software developers as a solution to the shortcomings of conventional models such as the Waterfall approach. The later development of DevOps practices in the late 2000s transformed software development by focusing on adaptability, teamwork with customers, and ongoing delivery.


3. List and briefly explain the phases of the Software Development Life Cycle.
(i). Problem Definition:- this initial stage identifies the problem to be solved and how it fits with current business opportunities and technology in line with the organisation goals and objectives.
(ii). Feasibility Study:- it is a research into the possibility of developing a solution to a problem. The study is to justify or nullify the change of modification of the current system.
(iii). System Analysis:- it is the process of collecting and analysing facts in respect of existing operations, procedures and systems in order to obtain a full appreciation of the situation prevailing so that an effective computerized systems may be designed and implemented.
(iv). System Design:- in this stage, designing the software happens according to the requirement specifications in order to come withe the best architecture for the software to be developed.
(v). Programming and Testing:- in this stage, developers have to follow the coding guidelines defined by their organization and programming tools like compilers, interpreters, debuggers are used to generate the code. The programming language is chosen with respect to the type of software being developed.
(vi). Implementation:- it is putting the software into live operation. This is after the system is fully tested, well documented and the staff to be involved in the running of the system are trained.
(vii). Review:- it is necessary to review the software to ensure that the initial aims of the system are being closely met.
(viii). Maintenance:- it includes all the activities associated with changing any program, procedure or documentation for an operational information system to keep the system operating correctly.


4. Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
(i). Approach:- Agile Methodology is iterative and incremental while Waterfall methodology is linear and sequential.
(ii). Documentation:- Agile methodology often lacks detailed documentation, which can complicate maintenance. Waterfall methodology, with its emphasis on documentation, can facilitate maintenance but may also create a burden if the documentation is overly complex or outdated.
(iii). Customer Interaction:- Agile maintenance relies on continuous customer interaction, making it easier to prioritize and address issues based on user needs. Waterfall’s long feedback loops can delay maintenance efforts and hinder responsiveness.
(iv). Team Dynamics:- Agile teams are cross-functional and may change frequently, which can impact knowledge continuity. Waterfall teams are typically more stable through the project lifecycle, aiding in the understanding of the system during maintenance.
(v). Flexibility and Rigidity: The Agile methodology allows for more flexibility in maintenance, adapting to user feedback and changing requirements. In contrast, Waterfall methodology has a rigid structure that can make it difficult to respond to changes once the system is deployed.
Scenarios Where Each Methodology is Appropriate
When to Use Waterfall Methodology
Waterfall Methodology is suitable for projects that have clear, fixed requirements and a structured development process, e.g., Banking Systems:- Financial applications with stringent compliance and security requirements.
When to Use Agile Methodology 
Agile works best in dynamic environments where requirements may change frequently and quick iterations are necessary, e.g., Digital Marketing and Web Development:- Websites and digital campaigns that need rapid adjustments based on trends and analytics.


5. Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer and a Project Manager in a software engineering team.
(i). Software Developer:- also known as a Programmer or Software Engineer is responsible for designing, coding, and implementing software applications.
Roles and Responsibilities
(a). Code Development:- Writing clean, efficient code based on project requirements and maintain the source code.
(b). Debugging and troubleshooting issues in the software during development and testing phases.
(c). Integrating software components, databases and Artificial Programming Interfaces(APIs).
(d). Implementing version control systems (e.g., Git) to manage code changes and collaborating with designers, product managers and other team members to develop software solutions.
(e). Documenting code including comments and technical specifications.
(f). Continuous learning and keeping up with industry trends, adopting new technologies to enhance developer skills.

(ii). Quality Assurance Engineer:- ensures the software meets quality standards by identifying and fixing defects before release.
Roles and Responsibilities
(a). Test Planning:- Develop test plans and strategies to ensure comprehensive coverage of application features and functionalities.
(b). Test Case Development:- Designing and executing test plans, test cases and test scripts.
(c). Manual and Automated Testing:- Performing manual and automated testing to identify bugs and performance issues.
(d). Defect Reporting:- Reporting and documenting software defects and verifying fixes.
(e). Regression Testing:- Conducting regression testing to ensure new updates don’t break existing features.
(f). Quality Metrics:- Analyse quality metrics and report on software performance to ensure new updates don’t break existing features.

(iii). Project Manager oversees the software development process, ensuring that the project is completed on time, within budget, and meets requirements.
Roles and Responsibilities
(a). Project Planning:- Defining project scope, objectives and deliverables.
(b). Timeline Management:- Create and manage project timelines, ensuring that projects are delivered on schedule.
(c). Team Leadership:- Provide guidance and support to team members ensuring a conducive and productive work environment.
(d). Risk Management:- Managing risks and resolving issues that may arise during development.
(e). Resource Management:- Allocate resources effectively, including team members, tools, and budgets in order to meet the set project objectives.
(f). Ensuring Agile or Waterfall methodologies are followed as per the project’s needs.


6. Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
Integrated Development Environments (IDEs) and Version Control Systems (VCS) are essential tools in the software development process. They are useful in improving efficiency, collaboration and code quality in software development. 

An IDE is a software application that provides a comprehensive set of tools to facilitate software development. It enhances productivity by offering features such as code editing, debugging, compiling, and project management within a single interface.
Importance of IDEs
(i). Integrated compiler and build Tools:- IDEs come with tools for compiling codes and building programs, simplifying the process of compiling and running code.
(ii). Debugging Tools:- IDEs come with built-in debugging tools that allow developers to set breakpoints, inspect variables, and step through code execution, making it easier to troubleshoot problems.
(iii). Error Detection: Most IDEs offer real-time syntax highlighting helping developers identify issues early in the development cycle.
(iv). Code Auto-completion:- there are IDEs that have code auto-completion which reduces development time by suggesting syntax and functions.
(v). Project Management: IDEs provide project templates, file organization and resource management features that help developers manage their projects effectively.

Examples of IDEs are Visual Studio Code(VSCode) and Code Blocks

A VCS is a tool that tracks changes to code over time, enabling developers to collaborate, revert to previous versions and manage different versions of a project efficiently.
Importance of VCS
(i). Collaboration:- a VCS allows multiple developers to work on the same project without overwriting changes.
(ii). Conflict Resolution: a VSC helps resolve conflicts when multiple developers edit the same file.
(iii). Code History Tracking:- VCS maintains a detailed history of all changes made to the codebase, enabling developers to review past versions and understand the evolution of the project.
(iv). Code Backup and Recovery:- a VCS provides a safety net by storing all versions of the code hence prevents data loss by storing previous versions of code.
(v). Branching and Merging: Developers can create separate branches to work on new features or fixes independently for features and merge them back into the main codebase when ready.
Examples of VCS are Git and Subversion


7. What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.

(i). Managing Complex Codebases:- As software projects grow, the codebase can become difficult to manage, leading to inefficiencies and bugs.

Strategies to overcome Complex Codebases:- Follow clean coding principles and maintain proper documentation and also implement modular programming to break large projects into smaller, manageable components.

(ii). Debugging and Testing:- Identifying and fixing bugs can be time-consuming and frustrating, especially in complex systems.

Strategies to overcome :- Implement automated testing (unit tests, integration tests) to catch bugs early and reduce the manual effort required for testing.

(iii). Meeting Tight Deadlines:- 

Strategies to overcome :- prioritise to focus on high-impact tasks first and also implementing the Agile methodology (Scrum, Kanban) to deliver work in smaller iterations.

(iv). Keeping Up with Technology:- 

Strategies to overcome:- Continuously learn through online courses, tutorials and to participate in tech conferences, hackathons, and developer communities.

(v). Handling Team Collaboration and Communication technicalities:-  

Strategies to overcome :- Schedule regular stand-up meetings to track progress and resolve blockers and document decisions and processes clearly to maintain transparency.

(vi). Work life balance with social life:- Software engineers often work long hours and this limits their time for interacting with their social lives, leading to stress fatigue and burnout.

Strategies to overcome Work life balance with social life are to set healthy work boundaries and take regular breaks and also engage in hobbies and physical activities to reduce stress that comes with pressure from work. 


8. Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

(i). Unit Testing:- Unit testing involves testing individual components or functions of a software application in isolation. Developers usually write unit tests during development to ensure each function, method or module works as expected. 

Example of Unit Testing:- A developer writing a function to calculate a user’s total shopping cart amount will create unit tests to check if the function returns the correct total for different inputs.

Importance of Unit Testing:- It ensures early bug detection and improved code quality.

(ii). Integration Testing:- Integration testing assesses the interaction between different modules or components of the software. It verifies that the different parts of the software interact as expected when combined.

Example of Integration Testing:- Testing whether a login module correctly communicates with the user authentication database and grants access to valid users while rejecting incorrect credentials.

Importance of Integration Testing:- It identifies interface issues and ensures compatibility

(iii). System Testing:- System testing evaluates the complete and integrated software product to ensure it meets specified requirements. It tests the end-to-end flow of the system, including performance, security and reliability.

Example of System Testing:- Testing a banking application by simulating real-world transactions, including deposits, withdrawals, and fund transfers, to ensure the entire system functions correctly.

Importance of System Testing:- It tests end-to-end validation and checks the performance of the system.

(iv). Acceptance Testing:- Acceptance testing is conducted to determine whether the software meets the acceptance criteria set by the stakeholders and whether it meets business and user requirements. It is typically conducted by end users or clients before final deployment. There are two types of acceptance testing namely User Acceptance Testing (UAT) and Beta Testing.

Example of Acceptance Testing:- A company launching an e-commerce website conducts acceptance testing to check if users can easily browse products, add items to the cart, and complete payments without issues.

Importance of Acceptance Testing:- It inquires about user satisfaction of the system hence giving the final validation.


Part 2: Introduction to AI and Prompt Engineering

9. Define prompt engineering and discuss its importance in interacting with AI models.

Prompt engineering:- this is the art of crafting questions or statements to get refined and the best responses from AI LLMs.


10. Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

Vague prompt:- Name the types of breeds pf dogs.

Improved prompt:- What are the top three breeds of dogs for families with young children, and what are their key characteristics?

Reasons why the improved is more effective
(i). Clarity:- by asking "what are the top three breeds of dogs for families with young children", this specific focus eliminates ambiguity about what aspect of dogs the user is interested in.
(ii). Preciseness:- narrows down the response, making it clear that the user is looking for a ranked list rather than general information about all dogs.
(iii). Conciseness:- the additional details provide a clear picture without being overly complicated making it easier for the response to be generated.
